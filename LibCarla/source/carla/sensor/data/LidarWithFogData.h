// Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/rpc/Location.h"
#include "carla/sensor/data/SemanticLidarData.h"

#include <cstdint>
#include <vector>

namespace carla
{
  namespace sensor
  {

    namespace s11n
    {
      class LidarWithFogSerializer;
      class LidarWithFogHeaderView;
    }

    namespace data
    {

      /// Helper class to store and serialize the data generated by a Lidar.
      ///
      /// The header of a Lidar measurement consists of an array of uint32_t's in
      /// the following layout
      ///
      ///    {
      ///      Horizontal angle (float),
      ///      Channel count,
      ///      Point count of channel 0,
      ///      ...
      ///      Point count of channel n,
      ///    }
      ///
      /// The points are stored in an array of floats
      ///
      ///    {
      ///      X0, Y0, Z0, I0
      ///      ...
      ///      Xn, Yn, Zn, In
      ///    }
      ///
#pragma pack(push, 1)
      class LidarWithFogDetection
      {
      public:
        geom::Location point;
        uint32_t intensity;
        uint32_t original_intensity;
        uint32_t is_modified;
        uint32_t actor_type;

        LidarWithFogDetection() : point(0.0f, 0.0f, 0.0f), intensity{0}, original_intensity{0}, is_modified{0}, actor_type{0} {}
        LidarWithFogDetection(float x, float y, float z, uint32_t intensity, uint32_t original_intensity, uint32_t is_modified, uint32_t actor_type) : point(x, y, z), intensity{intensity}, original_intensity{original_intensity}, is_modified{is_modified}, actor_type{actor_type} {}
        LidarWithFogDetection(geom::Location p, uint32_t intensity, uint32_t original_intensity, uint32_t is_modified, uint32_t actor_type) : point(p), intensity{intensity}, original_intensity{original_intensity}, is_modified{is_modified}, actor_type{actor_type} {}

        void WritePlyHeaderInfo(std::ostream &out) const
        {
          out << "property float32 x\n"
                 "property float32 y\n"
                 "property float32 z\n"
                 "property uint32_t I\n"
                 "property uint32_t M\n"
                 "property uint32_t T\n";
        }

        void WriteDetection(std::ostream &out) const
        {
          out << point.x << ' ' << point.y << ' ' << point.z << ' '
              << intensity << ' ' << intensity << ' ' << original_intensity << ' ' << actor_type;
        }
      };
#pragma pack(pop)

      class LidarWithFogData : public SemanticLidarData
      {
        static_assert(sizeof(float) == sizeof(uint32_t), "Invalid float size");

      public:
        explicit LidarWithFogData(uint32_t ChannelCount = 0u)
            : SemanticLidarData(ChannelCount)
        {
        }

        LidarWithFogData &operator=(LidarWithFogData &&) = default;

        ~LidarWithFogData() = default;

        virtual void ResetMemory(std::vector<uint32_t> points_per_channel)
        {
          DEBUG_ASSERT(GetChannelCount() > points_per_channel.size());
          std::memset(_header.data() + Index::SIZE, 0, sizeof(uint32_t) * GetChannelCount());

          uint32_t total_points = static_cast<uint32_t>(
              std::accumulate(points_per_channel.begin(), points_per_channel.end(), 0));

          _points.clear();
          _points.reserve(total_points);
        }

        void WritePointSync(LidarWithFogDetection &detection)
        {
          _points.emplace_back(detection);
        }

        virtual void WritePointSync(SemanticLidarDetection &detection)
        {
          (void)detection;
          DEBUG_ASSERT(false);
        }

      private:
        std::vector<LidarWithFogDetection> _points;

        friend class s11n::LidarWithFogSerializer;
        friend class s11n::LidarWithFogHeaderView;
      };

    } // namespace s11n
  }   // namespace sensor
} // namespace carla
